/// <reference path="../src/compiler/sys.ts" />

interface DiagnosticDetails {
    category: string;
    code: number;
    isEarly?: boolean;
}

interface InputDiagnosticMessageTable {
    [msg: string]: DiagnosticDetails;
}

function main(): void {
    var sys = ts.sys;
    if (sys.args.length < 1) {
        sys.write("Usage:" + sys.newLine)
        sys.write("\tnode processDiagnosticMessages.js <diagnostic-json-input-file>" + sys.newLine);
        return;
    }

    function writeFile(fileName: string, contents: string) {
        // TODO: Fix path joining
        var inputDirectory = inputFilePath.substr(0,inputFilePath.lastIndexOf("/"));
        var fileOutputPath = inputDirectory + "/" + fileName;
        sys.writeFile(fileOutputPath, contents);
    }

    var inputFilePath = sys.args[0].replace(/\\/g, "/");
    var inputStr = sys.readFile(inputFilePath);

    var diagnosticMessages: InputDiagnosticMessageTable = JSON.parse(inputStr);

    var names = Object.keys(diagnosticMessages);
    // Check that there are no duplicates.
    const seenNames = ts.createMap<true>();
    for (const name of names) {
        if (seenNames.has(name))
            throw new Error(`Name ${name} appears twice`);
        seenNames.set(name, true);
    }

    var infoFileOutput = buildInfoFileOutput(diagnosticMessages);
    checkForUniqueCodes(names, diagnosticMessages);
    writeFile("diagnosticInformationMap.generated.ts", infoFileOutput);

    var messageOutput = buildDiagnosticMessageOutput(diagnosticMessages);
    writeFile("diagnosticMessages.generated.json", messageOutput);
}

function checkForUniqueCodes(messages: string[], diagnosticTable: InputDiagnosticMessageTable) {
    const originalMessageForCode: string[] = [];
    let numConflicts = 0;

    for (const currentMessage of messages) {
        const code = diagnosticTable[currentMessage].code;

        if (code in originalMessageForCode) {
            const originalMessage = originalMessageForCode[code];
            ts.sys.write("\x1b[91m"); // High intensity red.
            ts.sys.write("Error");
            ts.sys.write("\x1b[0m");  // Reset formatting.
            ts.sys.write(`: Diagnostic code '${code}' conflicts between "${originalMessage}" and "${currentMessage}".`);
            ts.sys.write(ts.sys.newLine + ts.sys.newLine);

            numConflicts++;
        }
        else {
            originalMessageForCode[code] = currentMessage;
        }
    }

    if (numConflicts > 0) {
        throw new Error(`Found ${numConflicts} conflict(s) in diagnostic codes.`);
    }
}

function buildInfoFileOutput(messageTable: InputDiagnosticMessageTable): string {
    var result =
        '// <auto-generated />\r\n' +
        '/// <reference path="types.ts" />\r\n' +
        '/* @internal */\r\n' +
        'namespace ts {\r\n' +
        '    export const Diagnostics = {\r\n';
    for (const name of Object.keys(messageTable)) {
        var diagnosticDetails = messageTable[name];
        var propName = convertPropertyName(name);

        result +=
        '        ' + propName +
        ': { code: ' + diagnosticDetails.code +
        ', category: DiagnosticCategory.' + diagnosticDetails.category +
        ', key: "' + createKey(propName, diagnosticDetails.code) + '"' +
        ', message: "' + name.replace(/[\"]/g, '\\"') + '"' +
        ' },\r\n';
    }

    result += '    };\r\n}';

    return result;
}

function buildDiagnosticMessageOutput(messageTable: InputDiagnosticMessageTable): string {
    var result =
        '{';
    var names = Object.keys(messageTable);
    for (var i = 0; i < names.length; i++) {
        var name = names[i];
        var diagnosticDetails = messageTable[name];
        var propName = convertPropertyName(name);

        result += '\r\n  "' + createKey(propName, diagnosticDetails.code) + '"' + ' : "' + name.replace(/[\"]/g, '\\"') + '"';
        if (i !== names.length - 1) {
            result += ',';
        }
    }

    result += '\r\n}';

    return result;
}

function createKey(name: string, code: number) : string {
    return name.slice(0, 100) + '_' + code;
}

function convertPropertyName(origName: string): string {
    var result = origName.split("").map(char => {
        if (char === '*') { return "_Asterisk"; }
        if (char === '/') { return "_Slash"; }
        if (char === ':') { return "_Colon"; }
        return /\w/.test(char) ? char : "_";
    }).join("");


    // get rid of all multi-underscores
    result = result.replace(/_+/g, "_");

    // remove any leading underscore, unless it is followed by a number.
    result = result.replace(/^_([^\d])/, "$1")

    // get rid of all trailing underscores.
    result = result.replace(/_$/, "");

    return result;
}

main();